"""Anti-hallucination validator for LLM financial output.

This module validates LLM-generated text to ensure it only contains
financial figures that were explicitly provided in the prompt. Any
hallucinated amounts are flagged or replaced.

Design principle: Trust but verify - validate all LLM financial claims.
"""

from __future__ import annotations

import logging
import re
from dataclasses import dataclass, field
from decimal import Decimal

logger = logging.getLogger(__name__)


@dataclass
class ValidationResult:
    """Result of validating LLM output for financial accuracy."""

    is_valid: bool
    original_text: str
    sanitized_text: str
    hallucinated_amounts: list[Decimal] = field(default_factory=list)
    valid_amounts: list[Decimal] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    replacements_made: int = 0

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "is_valid": self.is_valid,
            "hallucinated_amounts": [float(a) for a in self.hallucinated_amounts],
            "valid_amounts": [float(a) for a in self.valid_amounts],
            "warnings": self.warnings,
            "replacements_made": self.replacements_made,
        }


class CostValidator:
    """Validates LLM output against provided financial figures.

    Extracts all monetary amounts from LLM output and verifies they
    match the amounts that were provided in the prompt. Hallucinated
    amounts can be flagged or replaced.
    """

    # Regex pattern for currency amounts
    # Matches: $1,234 | $1,234.56 | $1234 | 1,234 dollars
    CURRENCY_PATTERN = re.compile(
        r"\$[\d,]+(?:\.\d{1,2})?"  # $1,234 or $1,234.56
        r"|[\d,]+(?:\.\d{1,2})?\s*(?:dollars?|USD)",  # 1,234 dollars
        re.IGNORECASE,
    )

    # Pattern for extracting numeric value from currency string
    NUMERIC_PATTERN = re.compile(r"[\d,]+(?:\.\d{1,2})?")

    # Default tolerance for matching amounts (5%)
    DEFAULT_TOLERANCE = 0.05

    def __init__(
        self,
        tolerance: float = DEFAULT_TOLERANCE,
        replacement_text: str = "[amount unavailable]",
    ):
        """Initialize validator.

        Args:
            tolerance: Percentage tolerance for matching amounts (e.g., 0.05 = 5%).
            replacement_text: Text to replace hallucinated amounts with.
        """
        self.tolerance = tolerance
        self.replacement_text = replacement_text

    def extract_amounts(self, text: str) -> list[tuple[str, Decimal]]:
        """Extract all monetary amounts from text.

        Args:
            text: Text to extract amounts from.

        Returns:
            List of (original_string, decimal_value) tuples.
        """
        amounts = []

        for match in self.CURRENCY_PATTERN.finditer(text):
            original = match.group()
            numeric_match = self.NUMERIC_PATTERN.search(original)

            if numeric_match:
                numeric_str = numeric_match.group().replace(",", "")
                try:
                    value = Decimal(numeric_str)
                    amounts.append((original, value))
                except Exception:
                    logger.warning(f"Could not parse amount: {original}")

        return amounts

    def is_amount_allowed(
        self,
        amount: Decimal,
        allowed_amounts: list[Decimal],
    ) -> bool:
        """Check if an amount matches any allowed amount within tolerance.

        Args:
            amount: Amount to check.
            allowed_amounts: List of allowed amounts.

        Returns:
            True if amount matches an allowed amount within tolerance.
        """
        for allowed in allowed_amounts:
            if allowed == 0:
                continue

            diff = abs(amount - allowed) / allowed
            if diff <= self.tolerance:
                return True

        return False

    def validate(
        self,
        llm_output: str,
        allowed_amounts: list[Decimal],
    ) -> ValidationResult:
        """Validate LLM output against allowed amounts.

        Args:
            llm_output: Text generated by LLM.
            allowed_amounts: List of amounts the LLM was provided.

        Returns:
            ValidationResult with details of any issues found.
        """
        extracted = self.extract_amounts(llm_output)

        valid_amounts = []
        hallucinated_amounts = []
        warnings = []

        for original_str, amount in extracted:
            if self.is_amount_allowed(amount, allowed_amounts):
                valid_amounts.append(amount)
            else:
                hallucinated_amounts.append(amount)
                warnings.append(
                    f"Hallucinated amount detected: {original_str} "
                    f"(not in allowed: {[float(a) for a in allowed_amounts]})"
                )

        is_valid = len(hallucinated_amounts) == 0

        return ValidationResult(
            is_valid=is_valid,
            original_text=llm_output,
            sanitized_text=llm_output,  # Not sanitized yet
            hallucinated_amounts=hallucinated_amounts,
            valid_amounts=valid_amounts,
            warnings=warnings,
            replacements_made=0,
        )

    def sanitize(
        self,
        llm_output: str,
        allowed_amounts: list[Decimal],
    ) -> ValidationResult:
        """Sanitize LLM output by replacing hallucinated amounts.

        Args:
            llm_output: Text generated by LLM.
            allowed_amounts: List of amounts the LLM was provided.

        Returns:
            ValidationResult with sanitized text.
        """
        result = self.validate(llm_output, allowed_amounts)

        if result.is_valid:
            return result

        # Replace hallucinated amounts
        sanitized = llm_output
        replacements = 0

        for match in self.CURRENCY_PATTERN.finditer(llm_output):
            original = match.group()
            numeric_match = self.NUMERIC_PATTERN.search(original)

            if numeric_match:
                numeric_str = numeric_match.group().replace(",", "")
                try:
                    value = Decimal(numeric_str)
                    if not self.is_amount_allowed(value, allowed_amounts):
                        sanitized = sanitized.replace(original, self.replacement_text, 1)
                        replacements += 1
                except Exception:
                    pass

        result.sanitized_text = sanitized
        result.replacements_made = replacements

        return result

    def validate_and_log(
        self,
        llm_output: str,
        allowed_amounts: list[Decimal],
        context: str | None = None,
    ) -> ValidationResult:
        """Validate and log any issues found.

        Args:
            llm_output: Text generated by LLM.
            allowed_amounts: List of amounts the LLM was provided.
            context: Optional context string for logging.

        Returns:
            ValidationResult with details.
        """
        result = self.validate(llm_output, allowed_amounts)

        if not result.is_valid:
            context_str = f" [{context}]" if context else ""
            logger.warning(
                f"LLM hallucination detected{context_str}: "
                f"{len(result.hallucinated_amounts)} invalid amounts found"
            )
            for warning in result.warnings:
                logger.debug(warning)

        return result


def validate_financial_output(
    llm_output: str,
    allowed_amounts: list[Decimal],
    auto_sanitize: bool = True,
) -> tuple[str, ValidationResult]:
    """Convenience function to validate and optionally sanitize LLM output.

    Args:
        llm_output: Text generated by LLM.
        allowed_amounts: List of amounts the LLM was provided.
        auto_sanitize: Whether to automatically replace invalid amounts.

    Returns:
        Tuple of (output_text, ValidationResult).
    """
    validator = CostValidator()

    if auto_sanitize:
        result = validator.sanitize(llm_output, allowed_amounts)
        return result.sanitized_text, result
    else:
        result = validator.validate(llm_output, allowed_amounts)
        return llm_output, result


def extract_all_amounts(text: str) -> list[Decimal]:
    """Extract all monetary amounts from text.

    Convenience function for simple amount extraction.

    Args:
        text: Text to extract amounts from.

    Returns:
        List of Decimal amounts found.
    """
    validator = CostValidator()
    return [amount for _, amount in validator.extract_amounts(text)]


class StrictCostValidator(CostValidator):
    """Stricter validator that fails on any unrecognized amount.

    Use this for high-stakes financial communications where
    any deviation from provided figures is unacceptable.
    """

    def __init__(self):
        """Initialize with zero tolerance."""
        super().__init__(tolerance=0.0, replacement_text="[REDACTED]")

    def validate(
        self,
        llm_output: str,
        allowed_amounts: list[Decimal],
    ) -> ValidationResult:
        """Validate with zero tolerance.

        Any amount not exactly matching an allowed amount is flagged.
        """
        result = super().validate(llm_output, allowed_amounts)

        if not result.is_valid:
            result.warnings.append("STRICT MODE: All amounts must exactly match provided figures")

        return result


class WarningCostValidator(CostValidator):
    """Validator that warns but doesn't replace amounts.

    Use this when you want to log potential issues but not
    modify the output. Good for monitoring/debugging.
    """

    def sanitize(
        self,
        llm_output: str,
        allowed_amounts: list[Decimal],
    ) -> ValidationResult:
        """Validate but don't replace - just warn."""
        result = self.validate(llm_output, allowed_amounts)

        # Log warnings but don't modify text
        if not result.is_valid:
            for warning in result.warnings:
                logger.warning(f"Financial validation: {warning}")

        result.sanitized_text = result.original_text
        result.replacements_made = 0

        return result
